//
// ********************************************************************
// * License and Disclaimer                                           *
// *                                                                  *
// * The  Geant4 software  is  copyright of the Copyright Holders  of *
// * the Geant4 Collaboration.  It is provided  under  the terms  and *
// * conditions of the Geant4 Software License,  included in the file *
// * LICENSE and available at  http://cern.ch/geant4/license .  These *
// * include a list of copyright holders.                             *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.  Please see the license in the file  LICENSE  and URL above *
// * for the full disclaimer and the limitation of liability.         *
// *                                                                  *
// * This  code  implementation is the result of  the  scientific and *
// * technical work of the GEANT4 collaboration.                      *
// * By using,  copying,  modifying or  distributing the software (or *
// * any work based  on the software)  you  agree  to acknowledge its *
// * use  in  resulting  scientific  publications,  and indicate your *
// * acceptance of all terms of the Geant4 Software license.          *
// ********************************************************************
//
//
/// \file EventAction.cc
/// \brief Implementation of the EventAction class

#include "EventAction.hh"
#include "RunAction.hh"
#include "HistoManager.hh"
#include "G4Event.hh"
#include "G4RunManager.hh"
#include "G4ThreeVector.hh"

#include "EssHit.hh"
#include "G4SDManager.hh"
#include "G4HCofThisEvent.hh"

#include "G4RootAnalysisManager.hh"


#include <vector>
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

EventAction::EventAction(RunAction* runAction)
	: G4UserEventAction(),
	fRunAction(runAction),
	fCollectionID_A(-1),
	fCollectionID_B(-1),
	fCollectionID_BC(-1),
	fCollectionID_Pipe(-1),
	pos_x_A(-999), pos_x_B(-999), pos_z_A(-999), pos_z_B(-999),
	Energy_A(-999), Energy_B(-999), Phot_Elec_Energy(-999), Phi(-999), Theta(-999)
{}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

EventAction::~EventAction()
{}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void EventAction::BeginOfEventAction(const G4Event*)
{}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
void EventAction::EndOfEventAction(const G4Event* evt)
{
	G4HCofThisEvent* hcte = evt->GetHCofThisEvent();
	if (!hcte) return;

	//G4AnalysisManager* AnalysisManager = G4AnalysisManager::Instance(); // Just Histogram
	G4RootAnalysisManager* AnalysisManager = G4RootAnalysisManager::Instance();

	G4SDManager* SDMan = G4SDManager::GetSDMpointer();
	fCollectionID_A = SDMan->GetCollectionID("ElectrodeSD_A");
	fCollectionID_B = SDMan->GetCollectionID("ElectrodeSD_B");
	//fCollectionID_BC = SDMan->GetCollectionID("BeamCheckSD");
	fCollectionID_Pipe = SDMan->GetCollectionID("SDForElectron");

	EssHitsCollection* hc_A = 0;
	hc_A = (EssHitsCollection*)hcte->GetHC(fCollectionID_A);
	int nHits_A = hc_A->entries();
	for (G4int j = 0; j < nHits_A; ++j)
	{
		EssHit* hit = (*hc_A)[j];
		// The surface of electrode start y = -15 to -16
		G4ThreeVector pos = hit->GetPosition();
		if (pos.y() != -15) return;
		// only save values from first step in volume
		G4bool FirstStepInVolume = hit->GetFlag();
		if (FirstStepInVolume == false) return;
		pos_x_A = pos.x();
		pos_z_A = pos.z();
		Energy_A = hit->GetKineticEnergy();
		/*G4cout << "HERE X --> " << pos_x_A << "  ||  Z --> " << pos_z_A << G4endl;
		G4cout << "Copynum --> " << hit->GetCopyNumber() << G4endl;
		G4cout << "evtID --> " << evt->GetEventID() << G4endl;
		G4cout << "PDG  --> " << hit->GetParticleId() << G4endl;
		G4cout << "Deposit E --> " << hit->GetEdeposit() << G4endl;
		G4cout << "StepLength --> " << hit->GetStepLength() << G4endl;*/
		
		AnalysisManager->FillH1(0, pos.x());
		AnalysisManager->FillH1(2, pos.z());
		AnalysisManager->FillH1(4, Energy_A);
		AnalysisManager->FillH1(7, pos.x());
		AnalysisManager->FillH1(8, pos.z());
		AnalysisManager->FillH2(0, pos_x_A, pos_z_A);
		AnalysisManager->FillH2(1, pos_x_A, pos_z_A);

		AnalysisManager->FillNtupleDColumn(0, pos_x_A);
		AnalysisManager->FillNtupleDColumn(2, pos_z_A);
		AnalysisManager->FillNtupleDColumn(4, Energy_A);
		AnalysisManager->FillNtupleDColumn(7, pos_x_A);
		AnalysisManager->FillNtupleDColumn(8, pos_z_A);
		//G4int PID = hit->GetParticleId();
		//G4int copynumber = hit->GetCopyNumber();
		//if (PID == 11 && copynumber == 1 ) {
			//AnalysisManager->FillH1(6, Ekin);
			//AnalysisManager->FillNtupleDColumn(6, Energy_A);
		//}
		//pos_x_A = -999; pos_z_A = -999; Energy_A = -999;
	}
	EssHitsCollection* hc_B = 0;
	hc_B = (EssHitsCollection*)hcte->GetHC(fCollectionID_B);
	int nHits_B = hc_B->entries();
	for (G4int j = 0; j < nHits_B; ++j)
	{
		EssHit* hit = (*hc_B)[j];
		G4ThreeVector pos = hit->GetPosition();
		if (pos.y() != -15) return;
		G4bool FirstStepInVolume = hit->GetFlag();
		if (FirstStepInVolume == false) return;

		pos_x_B = pos.x();
		pos_z_B = pos.z();
		Energy_B = hit->GetKineticEnergy();
		
		AnalysisManager->FillH1(1, pos.x());
		AnalysisManager->FillH1(3, pos.z());
		AnalysisManager->FillH1(4, Energy_B);
		AnalysisManager->FillH1(7, pos.x());
		AnalysisManager->FillH1(8, pos.z());
		AnalysisManager->FillH2(0, pos_x_B, pos_z_B);
		AnalysisManager->FillH2(2, pos_x_B, pos_z_B);

		AnalysisManager->FillNtupleDColumn(1, pos_x_B);
		AnalysisManager->FillNtupleDColumn(3, pos_z_B);
		AnalysisManager->FillNtupleDColumn(4, Energy_B);
		AnalysisManager->FillNtupleDColumn(7, pos_x_B);
		AnalysisManager->FillNtupleDColumn(8, pos_z_B);

		//G4int PID = hit->GetParticleId();
		//G4int copynumber = hit->GetCopyNumber();
		//if (PID == 11 && copynumber == 2) {
			//AnalysisManager->FillH1(6, Ekin);
			//AnalysisManager->FillNtupleDColumn(6, Energy_B);
		//}
		//pos_x_B = -999; pos_z_B = -999; Energy_B = -999;
	}


	EssHitsCollection* hc_Pipe = 0;
	hc_Pipe = (EssHitsCollection*)hcte->GetHC(fCollectionID_Pipe);
	int nHits_Pipe = hc_Pipe->entries();
	for (G4int j = 0; j < nHits_Pipe; ++j)
	{
		EssHit* hit = (*hc_Pipe)[j];
		G4ThreeVector pos = hit->GetPosition();
		G4int copynumber = hit->GetCopyNumber();
		G4int PID = hit->GetParticleId();
		//G4cout << "here--Ekin --> " << hit->GetKineticEnergy() << G4endl;
		G4bool FirstStepInVolume = hit->GetFlag();
		if (PID == 11 && copynumber == 11 && FirstStepInVolume == true) {

			Phot_Elec_Energy = hit->GetPhotoElecEnergy();
			Phi = hit->GetMomentumDirection().getPhi() * (180 / CLHEP::pi);
			Theta = hit->GetMomentumDirection().getTheta() * (180 / CLHEP::pi);

			AnalysisManager->FillH1(10, Phot_Elec_Energy);
			AnalysisManager->FillH2(3, Phi, Phot_Elec_Energy);
			AnalysisManager->FillH2(4, Theta, Phot_Elec_Energy);
			AnalysisManager->FillH2(5, Theta, Phi);

			AnalysisManager->FillNtupleDColumn(10, Phot_Elec_Energy);
		}
	}

	/*
	EssHitsCollection* hc_BC = 0;
	hc_BC = (EssHitsCollection*)hcte->GetHC(fCollectionID_BC); // beam check , thin vacuum SD
	int nHits_BC = hc_BC->entries();
	for (G4int j = 0; j < nHits_BC; ++j)
	{
		EssHit* hit = (*hc_BC)[j];
		G4ThreeVector pos = hit->GetPosition();
		G4int PID = hit->GetParticleId();
		if (PID != 22 && pos.z() != -47) return;
		G4double Ekin = hit->GetKineticEnergy();
		AnalysisManager->FillH1(5, Ekin);
	}
	*/

	//AnalysisManager->FillNtupleDColumn(0, -999);
	//AnalysisManager->FillNtupleDColumn(1, -999);
	//AnalysisManager->FillNtupleDColumn(2, -999);
	//AnalysisManager->FillNtupleDColumn(3, -999);
	//AnalysisManager->FillNtupleDColumn(4, -999);
	// column id = 5 is for containing beam energy but not use now
	// column id = 6,9 is dummy
	//AnalysisManager->FillNtupleDColumn(7, -999);
	//AnalysisManager->FillNtupleDColumn(8, -999);
	//AnalysisManager->FillNtupleDColumn(10, -999);

	AnalysisManager->AddNtupleRow();
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
